\subsection{Crash States}
We define the \textit{crash state} as the on-disk state after a crash. It
comprises of the directory hierarchy and the data of all the files in the
hierarchy. After a crash, an application uses the crash state to recover to a
consistent state.  

The consistency of an application update protocol depends upon the developer
correctly handling all possible crash states. This is hard for
two reasons: first, there are a large numbers of possible crash states for even
simple protocols; second, the crash states that are possible vary from file
system to file system.

Ideally, it should be possible to determine which crash states are possible by
examining the system calls in the update protocol.  Unfortunately, the POSIX
standard defines how each system call should modify \textit{in-memory} state;
it does not specify what happens to the \textit{on-disk} state in the event of
a crash. Each file system \textit{implements} system calls differently, leading
to different behavior in the event of a crash.

\input{lst-example}
To illustrate this, we analyze the crash states of a small, simple update
protocol.  The protocol, shown in Listing~\ref{lst-example}, consists of only 4
operations.  Since there is no \smalltt{fsync()} in the protocol, the updates are
stored in the buffer cache when the protocol completes, and written to disk in
the background.

\input{tbl-crashstates}
Even this simple protocol can lead to many different on-disk states after a
crash. Some of these crash states are listed in Table~\ref{tbl-crashstates}. 
State \#0 is the initial state. States \#1, \#2, and \#3 occur as the protocol
proceeds in order. These states occur in all file systems.

State \#4 can occur in file systems where file data is not journaled. States
\#5 -- \#7 can occur in file systems with delayed allocation (e.g., ext4, xfs,
btrfs), where the append is persisted after the rename. States \#8 and \#9
represent the rename not being atomic -- this can happen only in ext2. State
\#10, where \smalltt{doc} ends up with data from another file, can happen with
file systems such as ext3, ext4, and reiserfs that have a writeback mode.

Thus, we have shown that the crash states possible for an update protocol vary
widely by file system. We have ascertained that certain properties of a system
call's implementation (and how system calls interact with one another)
determine the possible on-disk crash states. We term these as
\textit{persistence} properties. We define them more formally in
Section~\ref{sec-properties}, and investigate how they vary among a number of
current file systems. 

