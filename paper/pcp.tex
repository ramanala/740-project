\section{Persistence Properties}
\label{sec-properties} 
Each file system implements system calls in a different manner.
Application-level consistency is affected by some aspects of the implementation
of each system call. Modelling the implementation as \textit{persistence}
properties allows us to abstract away the aspects of the implementation that do
not affect application-level consistency, while capturing all the relevant
aspects.

In this section, we first present the intuition behind persistence properties.
We then formally define persistence properties and explain how we scope them.
We describe how we studied the persistence properties of various file
systems, and then discuss the results of the study.

\subsection{Intuition}
Application-level consistency is affected by the on-disk state after a crash.
Hence, aspects of the implementation that affect the on-disk state should be
captured. For example, persistence properties should capture whether the
changes made via a system call are all atomic, or whether a file is visible to
applications after a crash. On the other hand, implementation aspects that
relate to \textit{how} on-disk changes are made are irrelevant: it is enough to
know that a system call is atomic; it does not matter whether the atomicity is
provided through journaling,  copy-on-write, or some other mechanism. Two
file-system implementations that have the same persistence properties are
equivalent through the lens of application-level consistency, even if they
differ in other aspects.

The on-disk state is modified by a stream of I/O resulting from system calls:
hence it is enough for persistence properties to capture \textit{the manner in
which I/O becomes persistent on disk}.

\if 0
\subsection{Intermediate Disk Model}
\label{sec-intermediatemodel}
One way to model the implementation of system calls is to characterize each
system call by the \textit{intermediate} disk states possible during its
execution. This requires that the model capture two pieces of information: the
logical operations that make up each system call, and the ordering dependencies
between such logical operations.     Based on this, we can generate
intermediate disk states corresponding to various subsets of logical operations
being performed on-disk.

While this is a very natural way to express the characteristics of a system
call, the number of possible disk states for large system calls becomes very
high. Furthermore, it is hard to reason about the intermediate states and
compare them between file systems quickly. For this reason, we introduce the
notion of persistence properties.      
\fi

\subsection{Definition}
\label{sec-definition}
A persistence property characterizes one \textit{aspect} of system-call I/O at
a particular \textit{scope}. The aspect is either atomicity, durability, or
ordering. The scope constrains the set of system calls the persistence property
acts on, or the set of scenarios in which it is valid. 

\input{tbl-notation}
In this section, we first classify system calls to easily describe persistence
properties on groups of system calls. We then explain each aspect of
system-call I/O, and conclude with some examples of persistence properties.
Table~\ref{tbl-notation} introduces the notation we use to describe persistence
properties. 

\subsubsection{System Call Classification} 
We classify system calls into three broad kinds: \textit{file} operations
($F$), \textit{directory} operations ($Dir$), and \textit{sync} operations
($S$). Our persistence properties cover all the file-system related system
calls in the 3.2 Linux kernel.

File operations are concerned with only a single file and do not affect
directories.  The \smalltt{write()} and \smalltt{truncate()} system calls fall
into this category. Writes to an \smalltt{mmap()}-ed file are also considered
as file operations.

Directory operations are only concerned with the directory hierarchy. They do
not cause file data to be written. The following system calls are directory
operations:  \smalltt{link()}, \smalltt{unlink()}, \smalltt{creat()},
\smalltt{mkdir()}, \smalltt{rmdir()}, \smalltt{mknod()}, \smalltt{symlink()},
and \smalltt{rename()}. 

Sync operations persist the contents of a file or a directory.
\smalltt{fsync()}, \smalltt{fdatasync()}, \smalltt{sync\_file\_range()}, and
\smalltt{msync()} are treated as sync operations. Writes to file opened with
\smalltt{O\_SYNC} are also treated as if they were followed by
\smalltt{sync\_file\_range()} for the write.   

\subsubsection{Atomicity}
System call atomicity can be separated into two broad classes: file operation
atomicity and directory operation atomicity. For a file operation $F$,
atomicity could have two components: changing the size of $F$, and
changing/adding data to $F$. The size of the write/append is indicated by 
$size(F)$. Overwrites ($W$) do not change the file size. An atomic overwrite
therefore swaps the old content of the file with new data. Appends ($A$ and
$TA$) increase the file size and also add new data to the file. An atomic
append ($|A|$) does both operations atomically. A prefix-atomic append
($|A|^{P}$) atomically appends a prefix (e.g., the first 500 of 1000 bytes) of
the new data to the file.     

Directory operations like \smalltt{rename()} internally consist of multiple
logical operations (e.g., \smalltt{unlink()} and \smalltt{link()}). An atomic
directory operation does all the intern logical operations in an atomic
fashion.

\subsubsection{Durability}
When files and directories are not persisted explicitly in the update protocol,
they are made durable after a configurable interval of time by the file
system. This time interval varies by file system, and effectively reflects the
amount of data that can be lost upon a system crash.

\subsubsection{Ordering}
Consider two system calls ${X}^{a}_i$ and ${Y}^{b}_j$ where $i < j$. If there
is no ${S}^{a}_k$ where $ i < k < j$, then the ordering persistence property
characterizes whether $X$ is made durable before $Y$.

\subsubsection{Examples}
We list and explain a few persistence properties. We show how the meaning of
scope varies from one persistence property to another. 

$|F|\ \forall\ size(F) > 4096$. This atomicity persistence property
indicates whether file operations such as \smalltt{write()} that operate more
than a single block of data are atomic. This property has a very general scope:
a similar property with smaller scope would be $|W|\ \forall\ size(F) < 512$
which indicates whether overwrites of single sectors are atomic. Note that the
second property has smaller scope for two reasons: it operates on a smaller set
of operations (overwrites vs. all file operations) and only on single sector
writes versus all writes larger than a block. 

$Dir_i \to Dir_j$ where $i < j$. This ordering persistence property indicates
whether all directory operations are persisted in program order in the file
system. A similar property of narrow scope would be ${Dir}^{a}_i \to
{Dir}^{a}_j$ which indicates that all directory operations to the
\textit{same} directory are persisted in order.  

\if 0
$DT(W) <= 5$. This durability property indicates whether overwrite operations
are flushed to disk within 5 seconds by the file system. 
\fi

\subsection{Scoping Persistence Properties}
Persistence properties can vary in scope from the very general (e.g., all
system calls) to the very specific (e.g., one specific system call). Defining
the scope is one of the important parts of defining persistence properties for
a file system.

If we know the persistence properties that an application depends upon, we can
match it with the persistence properties of file systems and thus determine the
file systems on which it will be safe to run the application.

Therefore, it will be most useful if persistence properties of file systems can
be determined at the broadest scope possible. More specifically, this means if
a property is true at scope $X$, it should be true for all smaller scopes. It
should not be possible to combine two properties together to create a property
that is still true, but with a larger scope. For example, if property $F_{i}
\to F_{j}$ is true for a file system, then it will be preferred over two
properties $W_{i} \to W_{j}$ and $A_{i} \to A_{j}$.

\subsection{Estimating Persistence Properties}
\label{sec-framework}

It is difficult to estimate whether a persistence property is valid on a file
system. Ideally, file-system designers would document the properties that hold
on their file system. However, the implementation may not match the design.

We can use static analysis to prove that specific persistence properties hold
on file-system code. However, it is hard to ascertain properties like
durability from just static analysis~\cite{YangEtAl06-Explode}.   

% Framework
We have developed a framework to empirically test persistence properties.
While our framework cannot prove that a property is valid in all scenarios on a
file system (it can have false positives), it is useful in proving
counterexamples: that there are at least \textit{some} cases where the property
does not hold.   

% How it works
We first write a workload that exercises the systems calls related to the
property we want to test. For example, if we want to test $|W_i|$ for a
specific $size(W)$, our workload will contain writes of that size. 

The framework runs the workload and collects the block I/O traffic generated by
the file system. Using this traffic, it generates a number of unique disk
images corresponding to possible on-disk states after a system crash. 

We then write a checker that takes as input a disk image and verifies if the
property we are interested in holds on that disk image. For the $|W_i|$
example, the checker verifies the entire write has been performed atomically.
The framework runs the checker on all generated disk images. 

% The caveats
If the framework finds even a single disk image where the checker fails, then
we know that the property does not hold on the file system. Proving the
converse (that a property holds in all situations) requires some form of static
analysis. Nevertheless, for a general property like $Dir_i \to Dir_j$, testing
in this manner with a large number of random directory operations in the
workload helps build confidence that the property is valid on the file system.

\subsection{Study}
\label{sec-fs-properties}
\input{tbl-pcp}

We studied the persistence properties of 6 widely used file systems: ext2,
ext3, ext4, btrfs, xfs, and reiserfs. Each of these file systems is or has been
widely deployed and consequently a large number of applications have been
designed to be run on it. We also study configurations of these file systems
that have different consistency and durability guarantees. We study a total of
16 configurations in this manner.

For each configuration, we run a number of experiments testing different
persistence properties using the framework described in
Section~\ref{sec-framework}. Table~\ref{tbl-ppresults} lists the results of the  
experiments. We briefly discuss the results of testing each kind of persistence
property.

\textbf{Durability}. On most configurations, file overwrites were pushed to the
buffer cache, where they are eventually written to disk by the operating
system. On the Linux 3.2 kernel, the default writeback interval was 30 seconds.
The ext family of file systems make appends and directory operations durable in
5 seconds, while other file systems do so in 30 seconds.

\textbf{Atomicity}. Most modern disk drives provide atomic 512 byte writes.
Consequently, this is the basic guarantee provided by many file-system
configurations as well. Note that while overwriting a 512 byte sector is atomic
on all file systems, appending a sector is not: this requires modifications to
both the file and the data, and hence requires file-system machinery on top of
disk write atomicity. Depending on disk write atomicity might cause problems
when unmodified file systems are run on top of new technologies like PCM that
provide atomicity at single byte granularity. Only the data journaling and
copy-on-write configurations of file systems provide atomicity for 4K file
overwrites. Configurations that order data before metadata provide atomicity
for 4K file appends. For file operations larger than 4K, no configuration
provides guarantees: depending on when internal file-system operations
occur, the file operation could be broken into two or more operations.
However, many configurations do provide prefix-append atomicity: a prefix
of the data will be atomically added to the file.

\textbf{Ordering}. Since file overwrites are written to disk by the operating
system in the background, they are re-ordered with respect to other operations
in most configurations. On file systems such as ext4, btrfs, and xfs that
implement delayed allocation, appends can be re-ordered after other operations.
A special exception to this rule is when a file is appended to, and then
renamed. Since this is a common idiom to atomically update files, many file
systems recognize it and allocate blocks immediately. A similar special case is
appending to files that have been opened with \smalltt{O\_TRUNC}. We also point
out two ordering violations we noticed in btrfs: syncing a file that has been
appended to, or syncing a file in a directory where a rename operation has
taken place previously will result in those operations selectively being
written to disk (even if there are other earlier operations in the
\textit{same} directory waiting to be written out to disk).

\if 0
\subsection{Discussion}
We now discuss the sufficiency and completeness of persistence properties.

\textbf{Sufficiency}. We believe that all the aspects of an implementation that
affect application-level consistency can be expressed as a combination of
persistence properties at different scopes. We do not believe a new
\textit{class} of persistence properties will be required.  

\textbf{Completeness}. Since persistence properties have scope, it is almost
always possible to take a persistence property, reduce its scope, and get a new
persistence property that will potentially be valid on more file systems. For
example, the property of a \smalltt{write()} call being persisted before a
succeeding \smalltt{rename()} call is not valid on ext4, btrfs and reiserfs  --
but a \smalltt{write()} call to an existing portion of a file (an overwrite)
being persisted before a \smalltt{rename()} on the same file is valid on all
three. Thus it is impossible to define or list \textit{all} persistence
properties -- however, we believe that all such properties will hinge around
atomicity, durability, or ordering. 
\fi

