\section{Application-Level Consistency}
In this section, we first describe what it means for an application to be
consistent. We then explain how applications use system calls to persist
application state. We discuss why it is hard to write correct, efficient
application update protocols. We describe how the correctness of update
protocols depend on the implementation of system calls, which vary from file
system to file system. We explain how this introduces vulnerabilities in
applications.

% Perhaps next section?
%We show that such protocols are dependent on certain properties of file
%systems that vary widely from one file system to the next.

% Invariants, what it means to be consistent
\subsection{Consistency}
\label{sec-invariants}
Modern applications employ a large number of data structures to achieve good
user experience. These data structures are persisted in a large number of
files. For example, we observed that Google Chrome reads over 500 files when it
starts up.

Applications must maintain invariants over their persistent data structures.
For example, the contents of an user's browsing history in Google Chrome should
\textit{only} include web pages that they have visited. Another invariant is
that the history should contain \textit{all} the web pages previously visited.
When all the invariants of an application hold, it is deemed
\textit{consistent}. 

Many applications are required to be consistent even if the process or the
entire system crashes or loses power. In a process crash, all data in the
application's own buffers are lost but data in operating system buffers is
retained. In a system crash or power loss, all data that has not been persisted
is lost. After a system crash, the application must recover using only the
on-disk state. Hence, the on-disk state must be kept consistent at all times. 

% Application update protocols
%   - The three examples
%   Talk about isolation
\subsection{Application Update Protocols}
\input{fig-protocols}

Each application persists its state using a sequence of system calls. We term
this sequence the \textit{update protocol}. The update protocol determines
whether the application is consistent across crashes and thus is critical for
over-all application correctness.     

Figure~\ref{fig-protocols} shows three update protocols for applications. These
protocols represent simplified versions of update protocols used by SQLite in
different configurations. The protocols differ in how vulnerable they are to
crashes. 

%When the application is consistent across
%crashes, the application and its update protocol are deemed
%\textit{crash-consistent}.       

Protocol $(a)$ updates the database file using a single write. This protocol is
vulnerable to either a process or system crash: if the \smalltt{write()} call
is interrupted, the database could be partially updated (e.g., only the first
4096 bytes) leading to corruption.   

Protocol $(b)$ first writes to an application-level journal, and then to the
actual database. If a process crash interrupts the journal write, the database
in unaffected; if the process crashes in the middle of database write, SQLite
can use the journal to restore the database to a consistent state. However,
the protocol is not correct in the event of an inopportune system crash. Upon
completion of the \smalltt{write()} call, the data is stored in operating
system buffers, and can be written to disk in any order. Consider that the
operating system chooses to write out the database data first, and the system
crashes in the middle of the write. Since the database is partially updated, it
is in an inconsistent state. Furthermore, since the journal data was not
written to disk, the journal cannot be used to restore the database to a
consistent state.

Protocol $(c)$ solves this problem by using \smalltt{fsync()} to ensure that
the journal is persisted \textit{before} writing to the database file. A system
crash can only lead to one of two states. In the first case the journal was not
completely persisted.  In this case the update failed and the database remains
in the old, consistent state. In the second case the journal was completely
persisted, but the database may not have been completely updated.  The
journal is read, and the database updated to the new consistent state.
In either case, the database remains consistent. Thus the protocol is not
vulnerable to either process or system crashes.  

% Why it is hard to get them right
% 1. application state
% 2. Testing hard
\textbf{Protocol Complexity}. Ideally, application update protocols should
satisfy two requirements: they must be \textit{correct}, i.e., maintain
application consistency in the face of a process or system crash at any point;
and they must have \textit{good performance}.  

Naturally, there is a tension between these two requirements. For example,
protocol $(a)$ has the best performance of the three protocols in
Figure~\ref{fig-protocols}; however, it is vulnerable to process and system
crashes.   

% Disk state != Application state
Crash-consistent update protocols are hard to write because programmers normally
reason about \textit{in-memory} application state. For an update protocol to be
correct in the face of process and system crashes, the developer needs to
reason about all the different possible \textit{crash} states.  

\if 0
\subsubsection{Testing update protocols}
% Testing update protocols
Testing update protocols for system-crash bugs is hard. Such bugs leave the
application vulnerable for a brief period of time.   
\fi

% More hardness - file system implementations are different.
% High level table here?

\input{crashstate}

\subsection{Application Crash Vulnerabilities}
\input{fig-dependencies}

Since the implementation of system calls vary across file systems, it is hard
to write a correct, efficient update protocol that works across all file
systems. If an update protocol works correctly on one file system, but
incorrectly on another, we say the update protocol has a \textit{crash
vulnerability}: an incorrect assumption about how one or more system calls are
implemented in the underlying file system.  Figure~\ref{fig-dependencies}
illustrates how an application depends upon the persistence properties of ext4:
the application is vulnerable since other file systems may not share these same
properties. 

Crash vulnerabilities are problematic because the underlying assumption (that
certain persistence properties hold) isn't often explicitly mentioned in the
application code. Therefore, when a problem occurs due to an invalid
assumption, it is extremely hard to look at the application code and figure out
the root cause of the problem.  
