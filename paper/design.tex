\section{Design}
\subsection{Diskops, legal re-orderings, and constructing crashed states}
We generate diskops from micro-ops, corresponding to all the intermediate states specified by the model.

During a crash, a subset of diskops (among all micro-operations) might have gone to disk. However, only some subsets are legal, as constrained by the ordering rules of the abstract model. Given a legal subset, the state of the workload directory that corresponds to the crash can be constructed by applying the subset on top of the initial snapshot of the directory. Running the user-supplied checker on this constructed directory will validate whether the application correctly handles the particular crash instance.

\hl{May be describe the two/three objects involved in the model here?}
\hl{TODO: Explain what happens to a write() if the corresponding creat() is omitted.}

Forming a dependency graph between diskops based on the ordering constraints, and then doing a graph search, can find all legal subsets of diskops. For each legal subset, the set of externally visible actions (relating to durability) can also be found in a similar way.

However, an expansive search would result in too many states. For example, consider a single write call of 100 bytes; with the abstract model, this would be divided into a 100 diskops, resulting in 2**100 states.

\subsubsection{Truncating equivalent states from the search space.}
\hl{This is about how the omission/inclusion of a write() wouldn't matter if the creat() is omitted.

This is not currently implemented. It is straightforward to construct the resultant state corresponding to two sets of diskops, and then verify whether they are the same. This might be useful in, say, Postgres (where the checker is just really slow) with the omit-one heuristic.

However, a broader solution would only construct one of many equivalent states; the graph search mentioned in the previous subsection should pre-emptively only end up in one of the eqivalent states. The PL people have a lot of literature on this, and they can do this easily. In my opinion, whether we should implement (and write about) the broader solution depends on the actual mileage we would be getting out of it. If doing this allows us to run the 2**n for some of our workloads (need not be a generic solution, may be it will trim down only some of the trimmable states), we should do it. If it is easy to find a generic solution, we should do it. Otherwise, we should restrict ourselves to just improving Postgres-like situations.}

\subsection{Crashes specification}
While an exhaustive checking of all possible states reachable by the model does not scale, other (less complete) effective strategies can be used to identify bugs in lesser time. There are three observations that will be used here. First, an application developer might be able to provide information on whether certain generated states will be equivalent. Application developers might even want to test whether only a certain subset of the entire protocol is buggy. Second, heuristical search strategies can find bugs in common protocols. Third, in common scenarios, writing a correct protocol involves introducing many ordering operations, which will reduce the size of the search space.

%\noindent\textbf{Write and truncate intermediate states}: The model specifies that each byte involved in write or truncate micro-ops (including appends, unlink-truncates, and rename-truncates) can individually change. Thus, if an overwrite involves 100 bytes, a diskop will be generated for each of those bytes.

% However, consider for example that the protocol requires an overwritten region to be atomic. Most ways of violating it's atomicity will result in incorrectness observed by the checker. Hence, if the overwrite micro-op is split into two diskops 

% We believe that in most protocols, correctness violations related to any of the possible states generated by all 2 ** X combinations can be found by assuming only bigger portions of the writes change. This belief derives from the following intuition for overwrites: if an overwritten region is required to be atomic for correctness, most ways of violating it's atomicity will result in incorrectness observed by the checker.
\subsubsection{Default crashes specification}
In the default (application-agnostic) mode of running the tool, we split each write into a specific number diskops (three diskops in our experiments). Truncates and appends are also split similarly. The intuition behind this is \hl{TODO}.

We first test different prefixes of the protocol. If this does not produce any errors, we test cases where one diskop is omitted, and a crash occurs at different points in the protocol after that. If this also does not produce any errors, our tool starts exhaustive searching. It might be interesting to note here that, out of the ten applications we ran the tool on, only one application necessiated exhaustive searches.

The following is the intuition behind first testing for bugs in prefixes, then testing the omission of each diskop: \hl{TODO}.

\subsubsection{Customized crashes specification}
In certain scenarios, the user might have specific knowledge that can improve the default crashes-specification. For example, a certain write might be modifying important meta-information of the application, and the user might want to split it into multiple diskops (instead of just three), since affecting its atomicity in subtle ways might expose bugs. Alternatively, for a bunch of write micro-ops, the user might be confident that the recovery protocol verifies their atomicity using checksums, and just ignores all of them together if the checksum is a mismatch; in this case, all the micro-ops can be combining into a single diskop does not affect the effectiveness of testing, while lowering the testing time considerably.

The user can provide such knowledge to the testing framework.

\subsection{Customized file-system model}
The testing framework allows the user to test the application on top of a specific file-system model, instead of the abstract model proposed in previous sections. This requires the user to specify the behavior of the file-system as
\begin{itemize}
\item what diskops a micro-op will be split into.
\item the ordering dependencies between different diskops.
\end{itemize}
