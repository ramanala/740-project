======
Part 1
======

This is looking very nice.  I think you have the right flow of ideas
and generally at the right level.  I think the notation is helpful
too.

A couple of places can use some shortening (which I won't bother
mentioning now), a few can use elaboration (which I will mention), and
a few points could use more emphasis (which I will mention).

Section 2.1:
Emphasis point: Why is application-level consistency different than fs
consistency? - DONE

2.2:
Emphasis point: *Why* do applications have different protocols?  To
help make this point, I'd move  the point about "protocol complexity"
to the beginning of this section.  Maybe you want to say something
specific about fsync performance cost. - DONE

2.3:
Elaboration: how do you this analysis?  (you just consider all the
permutations of these system calls? or, do you need to say the details
will be described later?)  For clarification, can you show in Table 1
the combination of system calls that lead to each state? - DONE

3.1:
Wording: I like the paragraph on the intuition, but I don't think you
want to conclude with "the *manner* in which I/O becomes persistent on
disk".  Maybe just say, "it is enough for persistency properties to
simply capture *which* I/O becomes persistent on disk". - DONE, NO INTUITION 

Table 2:
I like the notation.  A few suggestions: - ALL REMOVED
- I'd start high level and then refine the scope (e.g., start with X,
then F, Dir, and S, then W and A, etc...)  Maybe indent to show which
are sub-categories of others???
- Instead of TA for append with truncate, I'd emphasize that it is A,
with T modifying it (e.g., AT ?).
- I'd separate in the table the properties from the operations (e.g.,
put some space before the line about "X is atomic"; move P(a) up).
- Would you say it is a "prefix-atomic append" or that the
prefix-append is atomic?  If the later, then I would use notation more
like |AP|  (i.e., modify the type of append with a P and then denote
that is atomic)
- I'd put XiYj means Y follows X in program order early in the table

======
Part 2
======

As we were saying in the meeting today, I think you should strive to
be consistent between the notation/terminology you use in Section 3
and Section 6.

I would suggest focusing on getting the entire paper complete before
fixing this next level of comments:

3.2.2
I don't think you are using F consistently (most of the time it is the
file operation, but a few times you use it to refer to the file). - DONE

3.2.5 Examples
I would intermix these examples with the subsections pertaining to
each property.  You have an example in here for atomicity and one for
ordering, which I would move up. - DONE

3.5 Study (Probably should be named "File System Results") - DONE

- You are right that durability doesn't really mesh with the other
properties.    I can't decide how you should handle durability in this
paper (but if you include it, please always discuss in the same order
in the paper...)  I don't think you are currently describing how you
measure durability. - DONE

- You need to give some overview about your results when you introduce
Table 3.   What can you generally say about each file system?  You
need some conclusion for this section. - DONE

4.1.1 File System Model
I feel like you need a higher-level description of your model.   Why
is your model realistic and/or practical?

The dependencies info is intuitive, but the atomicity model is not.
Why are links atomic and unlinks are not?

Since Detector starts with a system call trace, I think you need to
explain how your model maps system calls to logical operations and
then to micro operations.  I would describe your model from the top
down.

I think you can use Table 4 much earlier to explain how the model goes
from logical operations to micro ops.  (Maybe you should add fsync to
this table -- though I know it corresponds to dependencies and not to
micro-code.)  And, maybe you can add more information to the Table to
show op sizes (e.g., of overwrites and appends)?   Should truncate
also be in this table?

4.2.1 Currently, you explain micro-code as if the existence of those 4
ops is self-evident -- you need to give some intuition for why those
make sense as the base primitives.  (But, again, I would describe the
model from the top down.)
