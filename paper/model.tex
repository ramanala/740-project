\section{Model and howto}
\hl{TODO: Find an appropriate title. Model = principle?}
\subsection{Modeling the crash behavior of an abstract file system}
POSIX is useless. Posix-compliant ext2 can do a lot of weird things, and correct consistency protocols can simply not be written atop it. In order to find bugs in application consistency protocols, we have to construct a model for the different states that an abstract file system could end up in, if there is a system crash.
\hl{TODO: Verify ext2 claim by running with fsck.}

For the model, we talk about file system operations done by the application in terms of the following micro operations:
\begin{itemize}
\item create\_file(parent\_inode, file\_inode, dir\_entry)
\item unlink\_file(parent\_inode, dir\_entry)
\item link\_file(source\_inode, destination\_parent\_inode, destination\_inode)
\item mkdir(parent\_inode, dir\_inode)
\item rmdir(dir\_inode)
\item expand\_file(file\_inode, new\_file\_size)
\item truncate\_file(file\_inode, new\_file\_size)
\item append(file\_inode, data)
\item overwrite(file\_inode, offset, data)
\item sync(...)
\end{itemize}
\hl{TODO: Somehow reduce the number of micro-ops. This is good stuff in a journal paper, sleep medicine in a conference paper.}

Note that we do not provide micro operations corresponding to symlinks and file attributes. This was a design choice to keep our model simple; as will be apparent from the subsequent paragraphs, extending the model to include such operations is straight forward.

In addition to the list of micro operations, the model specifies
\begin{itemize}
\item Various intermediate states a micro operation can lead the file system to.
\item Orderings that should be held.
\end{itemize}

\subsubsection{Intermediate states of each micro operation}
\noindent\textbf{unlink\_file:} If the dir\_entry is the last link to the file, the intermediate states could be
\begin{itemize}
\item The link still exists, file size between the old file size and zero
\item The link does not exist.
\end{itemize}
\hl{TODO: Complete this subsubsection}

\subsubsection{Ordering and Durability}
All micro-operations sent to the disk can be re-ordered, except for the following constraints:

\hl{BLAH BLAH sync(...)}

In addition to the ordering constraints among the micro-ops themselves, the sync(...) calls also control the ordering between externally visible actions of the application and the micro-ops. This translates to the notion of durability.

\hl{BLAH BLAH?}

\hl{TODO: Discuss the two/three objects involved in the model somewhere? Hopefully not necessary.}

\subsection{How to check an application}

For checking an application, the user should provide test cases. Each test consists of the actual workload, a snapshot of the initial state of the workload directory before the test, and a checker that will evaluate whether a given simulated-crash-workload-directory state is correct.

\hl{Note on writing the paper: Explaining what the checker should do, is the most complicated part - how to check for consistency, and how to check for durability? Saying that, this is explained really well in EXPLODE, so extracting the relevant parts from EXPLODE should work.}

In addition to the test cases, the user can also provide an optional crashes-specification, and a custom file-system model. The crashes-specification provides a trade-off between completeness of the checker and the checking time; it is further explained in subsequent sections. The custom file-system model can be provided if the user is interested in the impact of a specific file-system, rather than an abstract file-system that can lead to all intermediate states and re-orderings discussed in the previous section.


