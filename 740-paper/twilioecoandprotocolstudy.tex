\section{Twilio Overview}
\label{sec-twilioecoandprotocolstudy}
In what follows, we describe the Twilio Ecosystem, some of the possible scenarios using the Twilio APIs, the experimental setup that we used for our study, high level protocol study and then packet level protocol study.
\subsection{Twilio Ecosystem}
\label{subsec-twilioeco}
The Twilio ecosystem, as depicted in the Figure~\ref{fig:ecosystem} can be viewed as a layered architecture. In the bottom most layer (layer 1) lie the $Twilio$  $servers$. These servers lay the foundation of this ecosystem by exposing a set of data and voice communication APIs for sending and receiving voice calls and messages. 

In the middle layer (layer 2), lie the $Application$ $servers$. These servers are installed by Twilio customers with dedicated Twilio accounts. For e.g. These application servers might belong to some company X that wants to provide VoIP service to its customer. Each Twilio account is linked to 1) one or more Twilio numbers, 2) an Account SID and 3) an Auth Token. A Twilio number is a ten digit phone number. Account SID is an unique identifier for a Twilio account. Auth Token is a token used by Twilio Servers to authenticate an account. The Application server uses the Account SID and Auth Token to access the Twilio APIs. The cost model for this second layer Application servers (or Twilio customers) is typically \textit{pay per message} or \textit{pay per call}. 

In the top most layer (layer 3), lie the $Clients$ which could be browser based clients or phone based clients. An important thing to note here is that these Clients are $not$ the direct customers of Twilio, instead they are the customers of the services that are built on top of Twilio. For e.g. These clients could be the customers of company X that is providing VoIP service. These clients, can be free customers or paid customers of company X. Also, depending on the type of service that the layer two based Twilio customers wants to provide, it is possible that, this layer three is non-existent.  The layer three Clients when present, in order to use the services and communicate with each other need to register with the layer one Twilio servers. This is done using a \textit{capability token} which is provided by the Application Server. 

So far we have only discussed how the Twilio clients connect to each other in the Twilio ecosystem. The Twilio clients and the Application servers can also interact with the external phones belonging to different carriers via the Twilio servers. Hence, these external phones also form a part of the Twilio ecosystem as shown in the figure.

\begin{figure}
\centering
%\begin{minipage}{.45\textwidth}
  \centering
  \includegraphics[width=0.45\textwidth]{figs/Ecosystem.png}
  %Mazu_frame_new.png}
\caption{Twilio Ecosystem}
\label{fig:ecosystem}
\end{figure}     
 \begin{figure}
 \centering
 %\begin{minipage}{.45\textwidth}
   \includegraphics[width=0.25\textwidth]{figs/TwiML.png}
 \caption{Sample TwiML Snippet}
 \label{fig:TwilML}
 \end{figure} 



\emph{Application Container: } Each Twilio number is linked to an application container. The application container contains two URLs: $Voice URL$ and $Message URL$. These URLs are configurable and are usually configured by the Application server administrators (or Twilio customers). Whenever an incoming call or message for a Twilio number arrives, the Twilio server makes post request to these URLs. Additionally, Twilio appends the \textit{query parameters} that it obtains from the end-clients before making the requests to the application servers. The content generated by these URLs direct Twilio servers to perform the needed actions on the incoming calls and messages. These contents are in form of a special markup language called $TwiML$ described in the subsequent section.  
\begin{figure*}[t!] 
\centering
%\begin{minipage}{.45\textwidth}
  \includegraphics[width=0.8\textwidth]{figs/auto.pdf}
\caption{Automated call to a phone}
\label{fig:autocall}
\end{figure*} 

\emph{TwiML:  } It is a markup language developed by Twilio. It contains a set of simple verbs that can be used by the Application Server to direct the Twilio servers about the action that needs to be taken whenever an incoming call or message is received to its number. Various kinds of verbs are supported as shown below which can be used to create interactive applications atop Twilio.
\begin{itemize}
\item Say - Read text to the caller 
\item Play - Play an audio file for the caller
\item Dial - Add another party to the call
\item Record - Record the caller's voice
\item Gather - Collect digits the caller types on their keypad
\item Sms - Send an SMS message during a phone call
\item Hangup - Hang up the call
\item Queue - Add the caller to a queue of callers.
\item Redirect - Redirect call flow to a different TwiML document
\item Pause - Wait before executing more instructions
\item Reject - Decline an incoming call without being billed
\end{itemize}

For e.g. The TwiML snippet shown in Figure~\ref{fig:TwilML} will say Hello World (dictated by the verb "say") to the caller in female voice (dictated by the attribute "voice"). Our experience with TwiML suggests that it is very simple to use and powerful with respect to the diversity of verbs that it supports.



\subsection{Scenarios}

There are multiple scenarios that one can enable with the help of Twilio Apis. Some of them are:

\begin{itemize}
\item $Automated$ $calls: $ Twilio APIs can be used to place automated calls to phone numbers to deliver a pre-recorded message.
\item $Voice$ $calls: $ VoIP applications can be built atop Twilio voice APIs which can be used to place voice calls. There are three scenarios possible for VoIP applications:  
\begin{itemize}
\item Call between VoIP Clients
\item Call from Phone to VoIP Client
\item Call from VoIP Client to Phone
\end{itemize}
\item $Messages: $ Twilio message APIs can be used to send automated messages.
\end{itemize}


\begin{figure*}[t!] 
\centering
%\begin{minipage}{.45\textwidth}
  \includegraphics[width=0.8\textwidth]{figs/twoclients.pdf}
\caption{Call between two VoIP clients}
\label{fig:2VoIPcall}
\end{figure*}
\subsection{Experimental Setup}

For our study, we developed a simple VoIP service (called VoT) atop Twilio and deployed it on OpenShift RedHat Cloud. The VoT server also hosts a simple web interface which can be used to place voice calls by specifying a phone number or the registered names of VoIP clients. For making automated calls and sending automated messages we have developed python scripts using the Twilio client libraries which directly calls into the Twilio APIs. For our study, we extensively use traces collected at different places. This includes application level trace messages collected at our VoT server, logs in Twilio user portal, Twilio object store queries and \textit{Wireshark} traces collected at client machines.

\subsection{High Level Protocol Study}
\label{subsec-protostudy}
We now present a high level protocol study of some of the important scenarios that Twilio supports. 

 
\begin{figure*}[t!] 
\centering
%\begin{minipage}{.45\textwidth}
  \includegraphics[width=0.8\textwidth]{figs/p2c.pdf}
\caption{Call from phone to a VoIP client}
\label{fig:callfromphone}
\end{figure*}

\emph{\textbf{Automated calls to phones:} }
The protocol diagram for this scenario is shown in  Figure~\ref{fig:autocall}. At first, a script (our python script) queues a call request specifying the phone number to which the call needs to be placed and an url indicating the location of the TwiML response. The Twilio server acknowledges the request and places the call. Once the phone attends the call, the Twilio server does a \textit{HTTP POST} or \textit{HTTP GET} to the url in the call queue request to fetch the TwiML response. In our experiments, we hosted these pre-recorded messages in our application server. The application server processes the request and sends a TwiML response in return. The Twilio server parses the TwiML response and finally streams the content to the phone.  

\emph{\textbf{Voice calls between VoIP clients:} }
The protocol diagram for this scenario is shown in Figure~\ref{fig:2VoIPcall}. Let us say, Mike and Jenny are the two VoIP clients and Mike wishes to call Jenny. As shown in Section~\ref{subsec-twilioeco}, for Mike and Jenny to communicate they need to first register with the Twilio Server. Hence, Mike and Jenny at first request the Application server for capability tokens. Once the Application server delivers the tokens, Mike and Jenny register with the Twilio server using the tokens. Mike then queues a call to Jenny. An interesting thing to note here is that the Twilio server does not have information about what to do with the call. It need to communicate with the Application server to get this information. For this, it triggers an incoming call to the Twilio number to which Mike is linked to. As stated in Section~\ref{subsec-twilioeco}, every incoming call to a Twilio number generates a post request on the voice URL present in the application container linked to that number. This post request is directed to the Application server with query parameter as "Jenny". The Application server parses the request and generates the appropriate TwiML content indicating the action that needs to be taken. In this case, the application server would serve a response that contains a \textit{Dial} verb and the client for the \textit{Dial} verb would be "Jenny". The Twilio Server parses the TwiML and places a call to Jenny. Finally, Mike is notified about this and the voice communication starts. Note that the actual voice communication is $not$ peer-to-peer and is routed via Twilio servers.  

\emph{\textbf{Voice calls from VoIP clients to phone:} }
The protocol diagram for this scenario is not shown for space constraints and is similar to that shown in Figure~\ref{fig:2VoIPcall} except the fact that Jenny has a dedicated phone number and hence does not need to register with the Twilio server. Lets say, Mike is a VoIP client and Mike wishes to call Jenny with a dedicated phone number (may belong to any carrier). Mike will at first request the Application server for a capability token. Once the Application server delivers the token, Mike will register with the Twilio server. Mike then places a call to Jenny's number. As in the case of two VoIP clients in the previous section, the Twilio server communicates with the Application server to get the information about the action that needs to be taken for the queued call. For this, it triggers an incoming call to the Twilio number linked with Mike. This incoming call generates a post request on the voice URL present in the application container. This post request is directed to the Application server with query parameter as "Jenny's phone number". The Application server parses the request, generates the appropriate TwiML content for the action that needs to be taken and delivers it to the Twilio server. The Twilio Server parses the TwiML and places a call to Jenny's phone. Finally, Mike is notified about this and the actual communication starts. 

\emph{\textbf{Voice calls from phone to VoIP clients:} }
The protocol diagram for this scenario is shown in Figure~\ref{fig:callfromphone}. Lets say, Mike is a VoIP client and a phone wishes to call Mike. Mike will first request the Application server for capability token with incoming capability. Once the Application server delivers the token, Mike registers with the Twilio server. When the phone calls the Twilio number associated with Mike, the Twilio server triggers an incoming call to that Twilio number. The incoming call generates a post request on the voice URL present in the application container. This post request is directed to the Application server. The Application server parses the request, generates the appropriate TwiML content for the action that needs to be taken and delivers it to the Twilio server. For our study purpose, whenever there is a call from a phone, the application server instructs Twilio through TwiML to forward the call to a pre-determined client name. In this case, the pre-determined name is Mike. The Twilio Server parses the TwiML and places a call to Mike. Finally, the phone is notified about this and the actual communication starts.

\subsection{Packet Level Analysis}
In this subsection, we dig deeper and present the packet level analysis for a scenario where a browser makes a voice call to a phone or another browser based client. 
%We also show another message level analysis for automated message sending scenario in section \ref{sec-oddities}. 

\begin{figure*}[t!] \centering
\includegraphics[width=\textwidth]{figs/voicecallpacketlevel.pdf}
\caption{\textbf{Voice Call from Browser Client} {\footnotesize\textit{
The figure shows sequence of packet exchanges that happen between the client and other components of the system. The top diagram shows the high level operations. The participants are shown above and below the top and bottom lines. The left bottom figure shows how the client interacts with the application server to obtain the \textit{capability token} and it corresponds to the first block in the top diagram. The right bottom diagram shows the sequence of messages exchanged between the client and the \textit{Twilio} server when the client executes the \textit{Twilio.Device.Setup} method and corresponds to the second block in the top diagram.  
}}}
\label{fig:messagelevel}
\end{figure*}

Figure~\ref{fig:messagelevel} shows the sequence of events that happens when a browser based client wants to make a VoIP call to another browser based client or a phone. As shown, at first the client browser does a \textit{HTTP GET} request to the application server that we have deployed. The application server generates a \textit{capability token} and passes it onto the client. The client side javascript includes the \textit{twilio javascript} library and does \textit{Twilio.Device.Setup} to register its capability with the \textit{Twilio} servers. The sequence of messages for the second block is also shown. The client passes the \textit{token} as \textit{HTTP} data after establishing a TLS session with the server. After this step, the client is free to make a call to either a phone number or another browser based client. The actual voice communication is tunneled through \textit{Twilio} servers and it involves \textit{RTMP} protocol. This sequence of packet exchanges are not shown due to space constraints. 
