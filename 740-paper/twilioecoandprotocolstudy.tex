\section{Twilio Overview}
\label{sec-twilioecoandprotocolstudy}
In what follows, we describe the Twilio Ecosystem, some of the possible scenarios using the Twilio APIs, the experimental setup that we used for our study, high level protocol study and then message level protocol study.
\subsection{Twilio Ecosystem}
\label{subsec-twilioeco}
The Twilio ecosystem, as depicted in the Figure~\ref{fig:ecosystem} can be viewed as a layered architecture. In the bottom most layer lie the $Twilio$  $servers$. These servers lay the foundation of this ecosystem by exposing a set of data and voice communication APIs for sending and receiving voice calls and messages. 

In the middle layer, lie the $Application$ $servers$. These servers are installed by Twilio customers with dedicated Twilio accounts. For e.g. These application servers might belong to some company X who want to provide VoIP service to its customer. Each Twilio account is linked to 1) one or more Twilio numbers, 2) an Account SID and 3) an Auth Token. A Twilio number is a ten digit phone number. Account SID is an unique identifier for a Twilio account. Auth Token is a token used by Twilio Servers to authenticate Application servers. The Application server uses the Account SID and Auth Token to access the Twilio APIs. The cost model for this second layer Application servers (or Twilio customers) is typically pay per message or pay per call. 

In the top most layer, lie the $Clients$ which could be browser based clients or phone based clients. An important thing to note here is that these Clients are $not$ the direct customers of Twilio, instead they are the customers of the layer two located Twilio customers. For e.g. These clients could be the customers of company X who is providing VoIP service. These clients, can be free customers or paid customers of company X. Also, depending on the type of service that the layer two based Twilio customers wants to provide, it is possible that these layer three is non-existent.  The Clients when present, in order to use the services and communicate with each other need to register with the layer three Twilio servers. This is done using a capability token which is provided by the layer two Application Server. 

\begin{figure}
\centering
%\begin{minipage}{.45\textwidth}
  \centering
  \includegraphics[width=0.45\textwidth]{figs/Ecosystem.png}
  %Mazu_frame_new.png}
\caption{Twilio Ecosystem}
\label{fig:ecosystem}
\end{figure}     

\emph{Application Container: } Each Twilio number is linked to an application container. The application container contains two URLs: $Voice URL$ and $Message URL$. These URLs are configurable and are usually configured by the Application server administrators (or Twilio customers). Whenever an incoming call or message for a Twilio number arrives, the Twilio server makes post request to these URLs. The content generated by these URLs direct Twilio servers to perform the needed actions on the incoming calls or messages. These contents are in form of a special markup language called $TwiML$ described in the subsequent section.

\emph{TwiML:  } It is a markup language developed by Twilio. It contains a set of simple verbs that can be used by the Application Servers to direct the Twilio servers about the action that needs to be taken whenever a call or message is received to its number. Various kinds of verbs are supported as shown below which can be used to create interactive applications atop Twilio.
\begin{itemize}
\item Say - Read text to the caller 
\item Play - Play an audio file for the caller
\item Dial - Add another party to the call
\item Record - Record the caller's voice
\item Gather - Collect digits the caller types on their keypad
\item Sms - Send an SMS message during a phone call
\item Hangup - Hang up the call
\item Queue - Add the caller to a queue of callers.
\item Redirect - Redirect call flow to a different TwiML document
\item Pause - Wait before executing more instructions
\item Reject - Decline an incoming call without being billed
\end{itemize}

For e.g. The TwiML snippet shown in Figure~\ref{fig:TwilML} will say Hello World (dictated by the verb "voice") to the caller in female voice (dictated by the verb "voice"). Our experience with Twiml suggests that it is very simple to use and powerful with respect to the diversity of verbs that it supports.
 
\begin{figure}
\centering
%\begin{minipage}{.45\textwidth}
  \includegraphics[width=0.25\textwidth]{figs/TwiML.png}
\caption{Sample TwiML Snippet}
\label{fig:TwilML}
\end{figure} 

\begin{figure*}[t!] 
\centering
%\begin{minipage}{.45\textwidth}
  \includegraphics[width=0.8\textwidth]{figs/auto.pdf}
\caption{Automated call to a phone}
\label{fig:autocall}
\end{figure*} 

\subsection{Scenarios}

There are multiple scenarios possible with the help of Twilio Apis. It include:

\begin{itemize}
\item $Automated$ $calls: $ Twilio APIs can be used to place automated calls to phone numbers to deliver a pre-recorded message or a text message read in female or male message.
\item $Voice$ $calls: $ VoIP applications can be built atop Twilio voice APIs which can be used to place voice calls. There are three scenarios possible for VoIP applications:  
\begin{itemize}
\item Call between VoIP Clients
\item Call from Phone to VoIP Client
\item Call from VoIP Client to Phone
\end{itemize}
\item $Messages: $ Twilio message APIs can be used to send and receive messages.
\end{itemize}

\subsection{Experimental Setup}

For our study, we developed a simple VoIP service (called VoT) atop Twilio and deployed it on OpenShift RedHat Cloud. The VoT server also hosts a website which is used to place voice calls by specifying a phone number or the registered names of VoIP clients. For making automated calls and sending automated messages we have developed python scripts using the Twilio client libraries which directly calls into the Twilio APIs. For our study, we extensively use traces collected at different places. This includes application level trace messages collected at our VoT server, logs in Twilio user portal, Twilio object store queries and wireshark traces collected at client machines.

\subsection{High Level Protocol Study}
\label{subsec-protostudy}
We now present a high level protocol study of some of the important scenarios that Twilio supports. 

\emph{\textbf{Automated calls to phones:} }
The protocol diagram for this scenario is shown in  Figure~\ref{fig:autocall}. At first, a script (our python script) queues a call request specifying the phone number to which the call needs to be placed and an url indicating the location where the message located. The Twilio server acknowledges the request and places the call. Once the phone attends the call, the Twilio server uses the url in the call queue request to contact the Application server and request the content (in form of TwiML) that needs to be delivered to the phone. The Application server processes the request and sends a TwiML response in return indicating the action that needs to be taken. The Twilio server parses the TwiML response and finally streams the content to the phone.  


\emph{\textbf{Voice calls between VoIP clients:} }
\begin{figure*}[t!] 
\centering
%\begin{minipage}{.45\textwidth}
  \includegraphics[width=0.8\textwidth]{figs/twoclients.pdf}
\caption{Call between two VoIP clients}
\label{fig:2VoIPcall}
\end{figure*}
The protocol diagram for this scenario is shown in Figure~\ref{fig:2VoIPcall}. Lets say, Mike and Jenny are the two VoIP clients and Mike wishes to call Jenny. As shown in Section~\ref{subsec-twilioeco}, for Mike and Jenny to communicate they need to first register with the Twilio Server. Hence, Mike and Jenny at first request the Application server for capability tokens. Once the Application server delivers the tokens, Mike and Jenny register with the Twilio server using the tokens. Mike then queues a call to Jenny. An interesting thing to note here is that the Twilio server does not have information about what to do with the call. It communicates with the Application server to get this information. For this, it triggers an incoming call to the Twilio number to which Mike is linked to. As stated in Section~\ref{subsec-twilioeco}, every incoming call to a Twilio number generates a post request on the voice URL present in the application container linked to that number. This post request is directed to the Application server with query parameter as "Jenny". The Application server parses the request and generates the appropriate TwiML content indicating the action that needs to be taken. It then delivers the TwiML content to the Twilio server. The Twilio Server parses the TwiML and places a call to Jenny. Finally, Mike is notified about this and the voice communication starts. Note that the actual voice communication is $not$ peer-to-peer and is routed via the Twilio VoIP server.  

\emph{\textbf{Voice calls from VoIP clients to phone:} }
The protocol diagram for this scenario is not shown for space constraints and is similar to that shown in Figure~\ref{fig:2VoIPcall} except that Jenny has a dedicated phone number and hence does not need to register with the Twilio server. Lets say, Mike is a VoIP client and Mike wish to call Jenny with a dedicated phone number (may belong to any carrier). Mike will at first request the Application server for a capability token. Once the Application server delivers the token, Mike will register with the Twilio server. Mike then queues a call to Jenny's number. As in the case of two VoIP clients in the previous section, the Twilio server communicates with the Application server to get the information about the action that needs to be taken for the queued call. For this, it triggers an incoming call to the Twilio number linked with Mike. This incoming call generates a post request on the voice URL present in the application container. This post request is directed to the Application server with query parameter as "Jenny's phone number". The Application server parses the request, generates the appropriate TwiML content for the action that needs to be taken and delivers it to the Twilio server. The Twilio Server parses the TwiML and places a call to Jenny's phone. Finally, Mike is notified about this and the actual communication starts. 
 
\emph{\textbf{Voice calls from phone to VoIP clients:} }
\begin{figure*}[t!] 
\centering
%\begin{minipage}{.45\textwidth}
  \includegraphics[width=0.8\textwidth]{figs/p2c.pdf}
\caption{Call from phone to a VoIP client}
\label{fig:callfromphone}
\end{figure*}
The protocol diagram for this scenario is shown in Figure~\ref{fig:callfromphone}. Lets say, Mike is a VoIP client and a phone wish to call Mike. Mike will first request the Application server for capability token. Once the Application server delivers the token, Mike registers with the Twilio server. When the phone calls the Twilio number associated with Mike, the Twilio server triggers an incoming call to that Twilio number. The incoming call generates a post request on the voice URL present in the application container. This post request is directed to the Application server. The Application server parses the request, generates the appropriate TwiML content for the action that needs to be taken and delivers it to the Twilio server. The Twilio Server parses the TwiML and places a call to Mike. Finally, the phone is notified about this and the actual communication starts.

\subsection{Packet Level Analysis}
In this subsection, we present the packet level analysis for a scenario when a browser make a voice call to a phone or another browser based client. We also show one more message level analysis for automated message sending scenario in section \ref{sec-oddities}. 

\begin{figure*}[t!] \centering
\includegraphics[width=\textwidth]{figs/voicecallpacketlevel.pdf}
\caption{\textbf{Voice Call from Browser Client} {\footnotesize\textit{
The figure shows sequence of packet exchanges that happen between the client and other components of the system. The top diagram shows the high level operations. The participants are shown above and below the top and bottom lines. The left bottom figure shows how the client interacts with the application server to obtain the \textit{capability token} and it corresponds to the first block in the top diagram. The right bottom diagram shows the sequence of messages exchanged between the client and the \textit{Twilio} server when the client executes the \textit{Twilio.Device.Setup} method and corresponds to the second block in the top diagram.  
}}}
\label{fig:messagelevel}
\end{figure*}

Figure~\ref{fig:messagelevel} shows the sequence of event that happens when a browser based client wants to make a VoIP call to another browser based client or another phone. As shown, at first the client browser does a \textit{HTTP GET} request to the application server that we have deployed. The application server generates a \textit{capability token} and passes it onto the client. The client side javascript includes the \textit{twilio js} library and does \textit{Twilio.Device.Setup} to register its capability with the \textit{Twilio} servers. The sequence of messages for the second block is also shown. The client passes the \textit{token} as \textit{HTTP} data after establishing a TLS session with the server. After this step, the client is free to make a call to either another browser based client or another phone number. The actual voice communication is tunneled through \textit{Twilio} servers and it involved \textit{RTMP} protocol. This sequence of packet exchanges are not shown due to space constraints. 
